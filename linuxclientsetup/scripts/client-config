#!/bin/bash

#Copyright (C) 2013 Robin McCorkell
#Original Copyright (C) 2006  Paul Sharrad
#This program is free software; you can redistribute it and/or
#modify it under the terms of the GNU General Public License
#as published by the Free Software Foundation; either version 2
#of the License, or (at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#The Karoshi Team can be contacted either at mpsharrad@karoshi.org.uk or rmccorkell@karoshi.org.uk
#
#Website: http://www.karoshi.org.uk

source /opt/karoshi/linuxclientsetup/utilities/common

####################
#Refresh client information
####################
#unset LOCATION
unset PRINTSERVER
unset PROXYSERVER
unset CLIENTSHUTDOWNTIME
unset IDLESHUTDOWNTIME
unset MAILSERVER
IFS=$'\n'
[[ -f /tmp/netlogon/clients/$CLIENTMAC ]] && read -r -d $'\0' _ _ LOCATION _ < /tmp/netlogon/clients/$CLIENTMAC
[[ -f /tmp/netlogon/domain_information/print_server ]] && read -r -d $'\0' PRINTSERVER _ < /tmp/netlogon/domain_information/print_server
[[ -f /tmp/netlogon/domain_information/proxy_server ]] && read -r -d $'\0' PROXYSERVER _ < /tmp/netlogon/domain_information/proxy_server
[[ -f /tmp/netlogon/domain_information/clientshutdowntime ]] && read -r -d $'\0' CLIENTSHUTDOWNTIME _ < /tmp/netlogon/domain_information/clientshutdowntime
[[ -f /tmp/netlogon/domain_information/idletime ]] && read -r -d $'\0' IDLESHUTDOWNTIME _ < /tmp/netlogon/domain_information/idletime
[[ -f /tmp/netlogon/domain_information/mail_server ]] && MAILSERVER=true
unset IFS

####################
#Set apt settings through proxy
####################
if [[ $PROXYSERVER ]]; then
	echo "Acquire::http::Proxy \"http://$PROXYSERVER.$DNSSUFFIX:3142/apt-cacher/\";" > /etc/apt/apt.conf.d/01proxy
fi

####################
#Domain specific stuff
####################
rm -f /etc/security/pam_mount.conf.xml
case "$DOMAINTYPE" in
samba4)
	[[ -f /tmp/netlogon/linuxclient/pam_mount.conf.xml.krb5 ]] && cp -f /tmp/netlogon/linuxclient/pam_mount.conf.xml.krb5 /etc/security/pam_mount.conf.xml
	;;
samba4_winbind)
	[[ -f /tmp/netlogon/linuxclient/pam_mount.conf.xml.krb5 ]] && cp -f /tmp/netlogon/linuxclient/pam_mount.conf.xml.krb5 /etc/security/pam_mount.conf.xml
	#Clear cache
	find /var/cache/samba -mindepth 1 -delete
	;;
samba3)
	[[ -f /tmp/netlogon/linuxclient/pam_mount.conf.xml ]] && cp -f /tmp/netlogon/linuxclient/pam_mount.conf.xml /etc/security/pam_mount.conf.xml
	#Clear cache
	find /var/cache/samba -mindepth 1 -delete
	;;
*)
	echo "Warning! Unrecognized domain type $DOMAINTYPE"
	;;
esac

#################
#Home areas
#################
#tmpfs auto mount
#[[ -f /etc/security/pam_mount.conf.xml ]] && sed -i "0,/[[:blank:]]*<volume/s@@<volume options=\"size=100m,uid=%(USERUID),gid=%(USERGID),mode=0700\" mountpoint=\"~\" uid=\"1000-50000\" fstype=\"tmpfs\" />\n<volume@" /etc/security/pam_mount.conf.xml

#Clear home areas
find /home -mindepth 1 -xdev -delete

####################
#Copy configuration
####################
[[ -d /tmp/netlogon/linuxclient/$LINUX_VERSION/configuration/ ]] && find /tmp/netlogon/linuxclient/$LINUX_VERSION/configuration -mindepth 1 -maxdepth 1 -print0 | xargs -0 cp -rf -t /

#Admin skel
[[ -e /opt/karoshi/admin-skel ]] && rm -rf /opt/karoshi/admin-skel
mkdir /opt/karoshi/admin-skel
if [[ -d /tmp/netlogon/linuxclient/$LINUX_VERSION/admin-skel/ ]]; then
	find /tmp/netlogon/linuxclient/$LINUX_VERSION/admin-skel -mindepth 1 -maxdepth 1 -print0 | xargs -0 cp -rf -t /opt/karoshi/admin-skel
elif [[ -d /tmp/netlogon/linuxclient/$LINUX_VERSION/admin_skel/ ]]
	find /tmp/netlogon/linuxclient/$LINUX_VERSION/admin_skel -mindepth 1 -maxdepth 1 -print0 | xargs -0 cp -rf -t /opt/karoshi/admin-skel
else
	find /opt/karoshi/linuxclientsetup/admin-skel -mindepth 1 -maxdepth 1 -print0 | xargs -0 cp -rf -t /opt/karoshi/admin-skel
fi

#Do skel (properly)
if [[ -f /tmp/netlogon/linuxclient/$LINUX_VERSION/skel.tar.gz ]]; then
	[[ -e /etc/skel ]] && rm -rf /etc/skel
	tar -x -C /etc -f /tmp/netlogon/linuxclient/$LINUX_VERSION/skel.tar.gz
fi
#/etc/skel should be readable by all, and directories should be 755
chown -R root:root /etc/skel
chmod -R +r /etc/skel
find /etc/skel -type d -print0 | xargs -0 chmod 755

#Version agnostic configuration
#Background images
[[ -f /tmp/netlogon/linuxclient/background.png ]] && cp -f /tmp/netlogon/linuxclient/background.png /opt/karoshi/images/
[[ -f /tmp/netlogon/linuxclient/login-background.png ]] && cp -f /tmp/netlogon/linuxclient/login-background.png /opt/karoshi/images/

#Clipboard sites for later on
[[ -f /opt/karoshi/allow_clipboard_sites ]] && rm -f /opt/karoshi/allow_clipboard_sites
[[ -f /tmp/netlogon/domain_information/allow_clipboard_sites ]] && cp /tmp/netlogon/domain_information/allow_clipboard_sites /opt/karoshi

#Copy domain CA certificate
[[ -f /opt/karoshi/cacert.pem ]] && rm -f /opt/karoshi/cacert.pem
[[ -f /tmp/netlogon/domain_information/cacert.pem ]] && cp /tmp/netlogon/domain_information/cacert.pem /opt/karoshi

#Static ARPs
[[ -f /tmp/netlogon/domain_information/static_arps ]] && arp -f /tmp/netlogon/domain_information/static_arps

#######################
#Thunderbird extensions
#######################

function do_xpi {
	xpi_name=$(basename "$1")
	xpi_name=${xpi_name%.xpi}
	
	if [[ -z $xpi_name ]]; then
		echo "Warning: Something bad happened" >&2
		return
	fi
	
	mkdir /opt/karoshi/thunderbird/extensions/"$xpi_name"
	unzip -q "$1" -d /opt/karoshi/thunderbird/extensions/"$xpi_name"
	
	xpi_id=$(xmlstarlet sel -N rdf=http://www.w3.org/1999/02/22-rdf-syntax-ns# -N em=http://www.mozilla.org/2004/em-rdf# \
				-t -m "//rdf:Description[@about='urn:mozilla:install-manifest']" -i "em:id" -v "em:id" --else -v "@em:id" \
				/opt/karoshi/thunderbird/extensions/"$xpi_name"/install.rdf)
	#Check if we actually have a valid extension id
	if [[ -z $xpi_id ]]; then
		echo "Warning: Thunderbird extension $xpi_name is invalid" >&2
		return
	fi
	
	#Install extension
	ln -Ts /opt/karoshi/thunderbird/extensions/"$xpi_name" /usr/lib/mozilla/extensions/{3550f703-e582-4d05-9a08-453d09bdfdc6}/"$xpi_id"
}

#{3550f703-e582-4d05-9a08-453d09bdfdc6} is the app-id for Thunderbird
[ -d /usr/lib/mozilla/extensions/{3550f703-e582-4d05-9a08-453d09bdfdc6} ] || mkdir -p /usr/lib/mozilla/extensions/{3550f703-e582-4d05-9a08-453d09bdfdc6}
[ -d /opt/karoshi/thunderbird/extensions ] || mkdir -p /opt/karoshi/thunderbird/extensions

if [ -d /tmp/netlogon/client_settings/thunderbird/extensions ]; then
	#Clear all extensions
	find /opt/karoshi/thunderbird/extensions -mindepth 1 -delete
	find /usr/lib/mozilla/extensions/{3550f703-e582-4d05-9a08-453d09bdfdc6} -maxdepth 1 -lname '/opt/karoshi/thunderbird/extensions/*' -delete
	
	#Global extensions
	while read -r -d $'\0' xpi; do
		do_xpi "$xpi"
	done < <(find /tmp/netlogon/client_settings/thunderbird/extensions -maxdepth 1 -mindepth 1 -name '*.xpi' -print0)
	#Linux-specific extensions
	if [ -d /tmp/netlogon/client_settings/thunderbird/extensions/linux-$(uname -i) ]; then
		while read -r -d $'\0' xpi; do
			do_xpi "$xpi"
		done < <(find /tmp/netlogon/client_settings/thunderbird/extensions/linux-$(uname -i) -maxdepth 1 -mindepth 1 -name '*.xpi' -print0)
	fi
fi

##########################
#Update the upstart scripts
##########################
[[ -f /tmp/netlogon/linuxclient/$LINUX_VERSION/utilities/karoshi-update.conf ]] && cp -f /tmp/netlogon/linuxclient/$LINUX_VERSION/utilities/karoshi-update.conf /etc/init
[[ -f /tmp/netlogon/linuxclient/$LINUX_VERSION/utilities/karoshi-idle-shutdown.conf ]] && cp -f /tmp/netlogon/linuxclient/$LINUX_VERSION/utilities/karoshi-idle-shutdown.conf /etc/init

###########################
#Create cronjob to shut computer down
###########################
if [[ $CLIENTSHUTDOWNTIME ]]; then
	echo Setting auto shutdown time at $CLIENTSHUTDOWNTIME
	hours=`cut -d: -f1 <<< "$CLIENTSHUTDOWNTIME"`
	minutes=`cut -d: -f2 <<< "$CLIENTSHUTDOWNTIME"`

	if [[ $hours ]] && [[ $minutes ]]
	then
		echo "SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=\"\"
HOME=/

$minutes $hours * * * /opt/karoshi/scripts/client-shutdown" | crontab -
	fi
fi

###########################
#Configure firewall
###########################
#Reset firewall to defaults
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
iptables -F
iptables -X

#Create and configure log deny chains
iptables -N LOGDROP
iptables -N LOGREJECT

iptables -A LOGDROP -j LOG
iptables -A LOGREJECT -j LOG

iptables -A LOGDROP -j DROP
iptables -A LOGREJECT -j REJECT

#Create Karoshi chains
iptables -N karoshi-local #Local rules
iptables -N karoshi-domain #Domain rules
iptables -N karoshi-auto #Auto-generated rules

#Add rules to INPUT chain
iptables -A INPUT -i lo -j ACCEPT #Allow all traffic on lo
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT #Allow established connections
[[ -e /tmp/netlogon/client_settings/firewall/no_ping ]] || iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT #Permit pings
iptables -A INPUT -j karoshi-local
iptables -A INPUT -j karoshi-domain
iptables -A INPUT -j karoshi-auto
[[ -e /tmp/netlogon/client_settings/firewall/drop_deny ]] || iptables -A INPUT -j REJECT #Reject all other packets

#Firewall rule processing
deny_target="LOGREJECT"
[[ -e /tmp/netlogon/client_settings/firewall/drop_deny ]] && deny_target="LOGDROP"
function process_rules {
	# $1 = file to process
	# $2 = iptables chain
	[[ $1 ]] || return
	if ! [[ -f $1 ]]; then
		echo "ERROR: Firewall rule processing: rule file $1 does not exist" >&2
		return
	fi
	[[ $2 ]] || return
	if ! iptables -n --list "$2" >/dev/null; then
		echo "ERROR: Firewall rule processing: chain $2 does not exist" >&2
		return
	fi
	
	(( line_no = 0 ))
	while read -r action protocol port source; do
		(( ++line_no ))
		if [[ $action ]] && [[ $action != \#* ]]; then
			rule=( )
			
			#Protocol
			case "$protocol" in
			all|any)
				;;
			*)
				if getent protocols "$protocol" >/dev/null; then
					rule+=( -p "$protocol" )
				else
					echo "$1:$line_no: Invalid protocol - $protocol" >&2
					continue
				fi
				;;
			esac
			
			#Port
			case "$port" in
			all|any)
				;;
			*)
				if getent services "$port" >/dev/null || ( [[ $port -gt 0 ]] && [[ $port -lt 65535 ]] ); then
					if ! ( [[ $protocol == "tcp" ]] || [[ $protocol == "udp" ]] ); then
						echo "$1:$line_no: Port option requires TCP or UDP protocol" >&2
						continue
					fi
					rule+=( --dport $port )
				else
					echo "$1:$line_no: Invalid port - $port" >&2
					continue
				fi
				;;
			esac
			
			#Source
			case "$source" in
			any|all|"")
				;;
			*)
				rule+=( --source "$source" )
				;;
			esac
			
			#Action
			case "$action" in
			allow)
				rule+=( -j ACCEPT )
				;;
			deny)
				rule+=( -j "$deny_target" )
				;;
			*)
				echo "$1:$line_no: Invalid action - $action" >&2
				continue
				;;
			esac
			
			#Commit rule
			iptables -A "$2" "${rule[@]}"
		fi
	done < "$1"
}

[[ -f /tmp/netlogon/client_settings/firewall/rules ]] && process_rules /tmp/netlogon/client_settings/firewall/rules karoshi-domain
[[ -f /opt/karoshi/firewall_rules ]] && process_rules /opt/karoshi/firewall_rules karoshi-local

#Generate auto rules
karoshi-generate-firewall-rules

#Set default policies - done last to prevent connection dropouts
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

###########################
#Update acceptable_use
###########################
[[ -f /tmp/netlogon/linuxclient/acceptable_use.txt ]] && cp -f /tmp/netlogon/linuxclient/acceptable_use.txt /opt/karoshi/
[[ -f /opt/karoshi/acceptable_use.txt ]] && chmod 0644 /opt/karoshi/acceptable_use.txt

###########################
#Update desktop icons for groups
###########################
[[ -e /opt/karoshi/desktop-icons ]] && rm -rf /opt/karoshi/desktop-icons
if [[ -d /tmp/netlogon/linuxclient/$LINUX_VERSION/desktop-icons ]]; then
	cp -rfT /tmp/netlogon/linuxclient/$LINUX_VERSION/desktop-icons /opt/karoshi/desktop-icons
elif [[ -d /tmp/netlogon/linuxclient/$LINUX_VERSION/desktop_icons ]]; then
	cp -rfT /tmp/netlogon/linuxclient/$LINUX_VERSION/desktop_icons /opt/karoshi/desktop-icons
fi

if [[ -d /opt/karoshi/desktop-icons ]]; then
	chmod -R 0644 /opt/karoshi/desktop-icons
	chmod -R u+X,g+X,o+X /opt/karoshi/desktop-icons
	while read file; do
		filename="$(tr '[:upper:] ' '[:lower:]-' <<< "$(basename "$file")")"
		mv "$file" "`dirname "$file"`/karoshi-$filename"
	done < <(find /opt/karoshi/desktop-icons/ -name "*.desktop" -and -not -name "karoshi-*.desktop")
fi

############################
#Printers
############################
#Turn off cups browsing
if [[ `grep -c "Browsing Off" /etc/cups/cupsd.conf` -eq 0 ]]
then
	echo "Browsing Off
BrowseInterval 0" >> /etc/cups/cupsd.conf
fi

#Assign printers depending on the location
if [[ $LOCATION ]]; then
	#Remove all printers
	while read -r printer _; do
		if [[ `lpstat -v $printer | grep 'smb:\|ipp:'` ]]; then
			echo Removing $printer
			lpadmin -x $printer
		fi
	done < <(lpstat -a)
	
	#Add printers
	if [[ $PRINTSERVER ]] && [[ -f /tmp/netlogon/printers.txt ]]; then
		all_printers=`grep $LOCATION /tmp/netlogon/printers.txt`
		if [[ $all_printers ]]; then
			printer_count=`cut -d, -f2 <<< "$all_printers"`
			default_printer=`cut -d, -f$(( printer_count + 3 )) <<< "$all_printers"`
			for (( i = 3; i < printer_count + 3; ++i )); do
				printer=`cut -d, -f$i <<< "$all_printers"`
				echo Adding printer $printer
				if [[ $DOMAINTYPE == samba3 ]]; then
					lpadmin -p $printer -v smb://$PRINTSERVER.$DNSSUFFIX/$printer -L "$LOCATION" -D "$printer" -E
				else
					lpadmin -p $printer -v ksmb://$PRINTSERVER.$DNSSUFFIX/$printer -L "$LOCATION" -D "$printer" -E
				fi
				#Copy PPD
				[[ -f /tmp/netlogon/linuxclient/printer_drivers/$printer.ppd ]] && lpadmin -p $printer -P /tmp/netlogon/linuxclient/printer_drivers/$printer.ppd
			done
			lpadmin -d $default_printer
		fi
	fi
fi

############################
#Update client
############################
#Use update var so that apt-get only updates once
apt_updated=false
#Only run if flag file is present
if [[ -f /tmp/netlogon/linuxclient/$LINUX_VERSION/enable_updates ]]
then
	echo Updating Software
	apt-get update
	apt_updated=true
	apt-get -y upgrade
fi

############################
#Install and remove software
############################
#Only run if flag file is present
if [[ -f /tmp/netlogon/linuxclient/$LINUX_VERSION/enable_software_install ]]
then
	#Install software
	if [[ -f /tmp/netlogon/linuxclient/$LINUX_VERSION/install_list ]]
	then
		#Only run apt-get update if it has not already run
		! $apt_updated && apt-get update
		install_list=`sed 's/ //g' /tmp/netlogon/linuxclient/$LINUX_VERSION/install_list`
		if [[ $install_list ]]; then
			apt-get -y install --no-upgrade $install_list
		fi
	fi
	
	#Remove software
	if [[ -f /tmp/netlogon/linuxclient/$LINUX_VERSION/remove_list ]]
	then
		remove_list=`sed 's/ //g' /tmp/netlogon/linuxclient/$LINUX_VERSION/remove_list`
		if [[ $remove_list ]]; then
			echo Removing Software
			apt-get -y remove $remove_list
		fi
	fi
fi

##########################
#Configure /opt/virtualbox
##########################
mkdir -p /opt/virtualbox
if ! grep -Eq '^[^[:space:]]+[[:space:]]+/opt/virtualbox[[:space:]]' /etc/fstab; then
	#Detect any SATA or SCSI drives with no partitions
	drive=$(parted -lms 2>/dev/null | sed -n '/BYT;$/ { n; /^\/dev\/sd./ { h; n; /^$/ { g; s/\([^:]*\):.*/\1/p; q; } } }')
	if [[ $drive ]]; then
		echo "Detected candidate drive for /opt/virtualbox: $drive"
		#Make GPT partition table and single logical partition
		parted -s "$drive" -- mktable gpt
		parted -s -a optimal "$drive" -- mkpart logical 0% 100%
		mkfs.ext4 "$drive"1
		
		#Copy data if required
		if ! [[ $(find /opt/virtualbox -maxdepth 0 -type d -empty 2>/dev/null) ]]; then
			mkdir -p /tmp/karoshi-virtualbox
			mount "$drive"1 /tmp/karoshi-virtualbox
			find /opt/virtualbox -mindepth 1 -maxdepth 1 -print0 | xargs -0 mv -t /tmp/karoshi-virtualbox
			umount /tmp/karoshi-virtualbox
			rmdir /tmp/karoshi-virtualbox
		fi
		
		#Write to /etc/fstab
		uuid=$(lsblk -no UUID "$drive"1)
		echo "# karoshi: /opt/virtualbox" >> /etc/fstab
		echo "UUID=$uuid	/opt/virtualbox	ext4	defaults	0	2" >> /etc/fstab
		
		mount /opt/virtualbox
	fi
fi

##########################
#Miscellaneous things
##########################

#Restrict cron and at to root
echo root > /etc/cron.allow
echo root > /etc/at.allow

#Enable trim support in fstab
for device in /dev/sd*; do
	device_uuid=`blkid $device | sed 's@.*UUID="\([^"]*\)".*@\1@'`
	if [[ $device_uuid ]] && [[ `hdparm -I $device | grep TRIM` ]]; then
		sed -i "/swap\|discard,noatime/!s@\(UUID=$device_uuid[[:blank:]]\+[^[:blank:]]\+[[:blank:]]\+[^[:blank:]]\+[[:blank:]]\+[^[:blank:]]\+\)@\1,discard,noatime@" /etc/fstab
	fi
done

#Write new variables to file
updateVariables
